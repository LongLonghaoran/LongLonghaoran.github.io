<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.17 (463232)"/><meta name="author" content="过眼云烟"/><meta name="created" content="2022-07-05 05:51:26 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2022-08-30 09:58:15 +0000"/><title>Go程序设计语言 疑难点记录</title></head><body><div><span style="font-size: 24px;">第一章 入门:</span></div><div><span style="font-size: 18px;">1.</span>make(map[string]int)构造的map值,其value部分会自动初始化为零值,而new(map[string]int)构造的map值是整个都是nil值,无法通过构造出来的值访问</div><div><span style="font-size: 18px;">2.</span>map作为实参传递给函数时,函数内对形参的改变会影响到实参,因为map是引用类型</div><div><span style="font-size: 18px;">3.</span>if语句的条件部分可以同时写短的用分号连接的语句，这样语句中的变量的作用域仅限于if语句代码块中</div><div><br/></div><div><span style="font-size: 24px;">第二章 程序结构:</span></div><div><span style="font-size: 18px;">1.包级别的初始化在main函数开始之前进行，局部变量的初始化在函数执行期间进行</span></div><div><span style="font-size: 18px;">2.短变量声明需要声明至少一个新变量</span></div><div><span style="font-size: 18px;">3.变量的生命周期是由该变量是否可访问决定的</span>，对于包级别的变量的，该变量在程序执行期间始终可访问，所以它始终存在，而对于函数内部声明的局部变量，当函数执行完成后变量也就不可访问，所以这个变量将会被垃圾回收，但是如果函数在返回时通过返回该变量的地址给外部的指针变量，那么该变量在函数结束后则仍然可以访问，那么该变量就还是存活的，不会被垃圾回收</div><div><span style="font-size: 18px;">4.词法块含义</span>:分为显示和隐式的词法块，也可叫语句块/代码块，显示词法块的用{}包裹的代码块，隐式词法块的就是if for switch语句的条件或者初始化部分的语句，它们处于隐式创建的词法块中，它们的作用域限于if for switch之后的词法块中</div><div><br/></div><div><span style="font-size: 24px;">第三章 基本数据:</span></div><div><span style="font-size: 18px; font-family: HelveticaNeue; font-style: normal;">1.四大类型</span></div><div>1.1 基础类型: 数字 字符串 布尔</div><div>1.2 聚合类型:数组 结构体</div><div>1.3 引用类型:指针 切片 map 通道</div><div>1.4 接口类型</div><div><span style="font-size: 18px;">2.按位置零</span> &amp;^ 运算符，将一个数的指定位置的二进制位置为0，通过第二个操作数的对应位置设置为1就可以让其计算位0，比如7的二进制是00000111,现在希望其第二个1设置为0，变成这样00000101，那么通过按位置零运算符，我们用00000010这个数来和它运算就可以了,00000010的十进制是3，所以就是说7&amp;^3等于5</div><div><span style="font-size: 18px;">3.-1&gt;&gt;1的结果是多少?</span></div><div>移位操作中,有符号数的移位操作是按符号位的值补空位，无符号数以0补空位，-1的符号位是1，它的二进制表达为1111 1111，8个1，右移一位之后为 _111 1111，最左边多出一位空位，补个1，结果为 1111 1111，所以结果仍然是-1，因此，如果以位模式处理整数时，一定使用无符号类型来处理。</div><div><span style="font-size: 18px;">4.字节序列和unicode码点是如何转换的:</span></div><div>字符的码点值意思是unicode字符编码顺序的原本序号,字节序列是将码点的二进制形式拼接特定的01之后而成的</div><div><img src="Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20%E7%96%91%E9%9A%BE%E7%82%B9%E8%AE%B0%E5%BD%95.resources/EC8FDECA-87F7-4FDC-BADE-9E7382D7316C.png" height="698" width="1112"/><br/></div><div>通过打印 "我"字的字节序列和unicode码点,得出,字节序列是230 136 145,而码点是25105,二者的二进制形式分别为:</div><div>25105: 0110 0010 0001 0001</div><div>230 136 145: 1110 0110 1000 1000 1001 0001</div><div>这是因为对于需要多个字节表示的字符,其字节序列的表示规则为:</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="box-sizing: border-box;-en-paragraph:true;">对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为 0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">参考: <a href="https://liyucang-git.github.io/2019/06/17/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81/">https://liyucang-git.github.io/2019/06/17/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81/</a></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">5.fmt包打印字符串时, \uhhhh表示按unicode码点来表示对应的unicode字符,hhhh是4位16进制数,对应unicode中对应序号的字符</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">\xhh\xhh\xhh是表示用字节序列来打印unicode字符</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 24px;">第四章:复合数据类型</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">1.slice的零值是nil</span>(而数组的零值是其各个元素置为零值),所以slice可以和nil做比较运算,所有值可以为nil的值,都可以通过转换表达式转换类型T(nil)</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">2.可比较性</span>:golang中不是每种类型的值都可以和任意值做==比较,数组之间的==比较的是元素值是否相等,并且数组是否可以比较也取决于元素值之间是否可以比较;slice之间不能进行==比较;结构体是否可比较取决于是否所有成员变量都可以比较。可比较性和可赋值性是挂钩的，两个操作数可以比较的前提是这两个操作数可以互相赋值。</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">3.</span><span style="font-size: 18px;">结构体数据作为函数参数或者返回值通常使用指针的原因是:</span><span style="font-size: 14px;">出于效率考虑,当然这种方式对于函数需要修改结构体内容的时候也是必需的，在go语言中调用函数的参数接收到的是实参的副本，并不是实参的引用。</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">4.如果嵌套的结构体不可导出,而其子成员变量可导出时,那么仍然可以通过快捷方式使用成员变量:</span></div><div><span style="font-size: 14px;">比如:</span></div><div>Package A:</div><div>type point struct { X,Y int}</div><div>type circle struct {</div><div>point</div><div>Radius int</div><div>}</div><div>type Wheel struct {</div><div>circle</div><div>Spokes int</div><div>}</div><div>Package B:</div><div>import "A"</div><div>w := A.Wheel{}</div><div>B导入了A，注意这里直接使用</div><div>w.circle.Radius w.circle.point.X 肯定是不行的，但是golang允许我们通过w.X w.Radius来使用匿名</div><div>成员结构体中的成员变量</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">5.结构体的初始化方式只有两种,要么按顺序给出所有成员变量的值,要么以键值对的方式给出成员值,不能混用两种方式</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">6.接收http响应的时候,要解析其中的json格式body内容,</span><span style="font-size: 14px;">需要使用流式解析json.NewDecoder(resp.Body).decode(result),如果要使用json.Unmarshal的话,需要使用ioutil.ReadAll(resp.Body)来流式读出全部内容才可以</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 24px;">第五章:函数</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">1.Go语言的GC垃圾回收机制会回收未使用的内存，但是不会释放未使用的操作系统资源，所以必须显示地关闭它们:</span> <span style="font-size: 14px;">比如我在代码中声明了一个基本数据类型的变量并初始化给它赋了值 a := 1, 那这种语句就是纯粹的程序内存使用,当a所在的函数执行结束后,a就会释放掉(如果没有通过&amp;取地址逃逸的话), 但是如果是File.Open或者http.Get这样去打开一个文件或者发起一个网络请求的操作,那它涉及的就不仅仅只是golang中的变量赋值了,它还会涉及到实际操作系统上的资源创建(文件、网络连接)，这种我们就得显示地给它关闭</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">2.函数签名也叫函数类型:</span> <span style="font-size: 14px;">函数签名指的是函数的形参列表和返回值，当两个函数的形参列表和返回值相同时，说明两个函数签名/函数类型是一样的。</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">3.函数变量的可比较性:</span> <span style="font-size: 14px;">函数类型相同的两个函数变量才可以互相赋值,函数变量可以和nil做比较，但是两个函数变量之间不能进行比较，所以也不能作为map的键使用</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">4.defer语句必须是一个函数或者方法调用</span><span style="font-size: 14px;">，如果该函数或者方法调用的返回结果仍然是一个函数，那么可以继续调用该函数，比如 defer a()() ，实际的效果就是，a会先执行，但是a函数返回的那个函数会在整个外部函数调用完成之后再调用</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">5.defer通常是在成功获得资源之后使用,</span><span style="font-size: 14px;">defer通常用于成对的操作，比如文件打开和关闭，网络连接和断开,通常在第一步成功之后就使用defer调用关闭操作,一个函数中可以有多个defer调用，执行的时候按照调用defer的顺序的倒序进行。</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">6.findlinks程序难度较大，使用递归来处理html文档</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 24px;">第六章:方法</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">1.p121:同一个包任何类型都可以声明方法，只要它的类型既不是指针类型也不是接口类型。</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14px;">这句话的意思是:声明方法时的接收者的数据类型本身不能是另一个指针类型的命名类型，也不能是一个接口类型。首先方法的接收者的数据类型必须是一个命名类型，不能是基础数据类型。所以上述的不能是指针类型意思是:</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14px;">type MyInt *int</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14px;">func (my MyInt) m1(){} //这样是不行的，因为MyInt是指针的命名类型</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;"><br/></span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">2.当方法的接受者形参是指针类型，而实参是结构体字面量时，无法通过结构体字面量直接调用方法，比如:</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14px;">type Point struct { X,Y int}</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">func (p *Point) Distance(q Point) float64{</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">    return math.Hypot(q.X-p.X, q.Y-p.Y)</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">}</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">对于上面定义的结构体和方法,直接通过Point的实例字面量调用方法是不行的:</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">Point{1,2}.Distance(Point{4,6}) //注意这是错误的</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">因为go无法获取临时变量的地址，所以无法对Point{1,2}做隐式转换。</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">3.对于类型T,不论其方法是声明在T上的还是*T上的，都可以直接通过T的实例或者*T的实例直接进行调用</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">4.结构体实例或者数据量较大的数据类型类型，在作为方法接收者或者形参的时候应该使用指针作为参数，目的是为了程序运行效率更高占用更少内存，应该在调用方法或者给函数传递参数的时候，都会将接收者或者实参复制一个实例出来。</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">5.结构体类型嵌套的时候,内层结构体的方法也会被外层的结构体共享</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">6.未命名结构体类型的写法:</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">struct{</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">v T</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">}</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">初始化写法:</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="box-sizing: border-box;">s := struct{</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="box-sizing: border-box;">v T</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="box-sizing: border-box;">}{}</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="box-sizing: border-box;"><span style="font-size: 18px;">7.P129实现了一个整数集合的功能，含有并集、交集、含有性判断的方法</span></span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 24px;">第七章:接口</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">1.之所以 T类型变量调用*T的方法或者*T类型变量调用T的方法，是因为Go提供的语法糖，这一旦用在接口赋值上就不灵了</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">比如:</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">type Stringer interface{</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">    String() string</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">}</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">type myint int</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">func (*myint) String() string {</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">    fmt.Sprint("abc")</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">}</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">var s Stringer</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">var i myint = 1</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">//按照上面的声明，把i赋值给s是不行的，因为真正实现String方法的是&amp;i(*myint)</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">s = i</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14pt;">2.通过T类型变量调用定义在*T上的方法或者通过*T类型变量调用定义在T类型上的方法，本质上是Go语言中的语法糖</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">所以需要注意一个易错的地方: 当在*T上定义了一个方法m时，将T类型的变量赋值给声明了m方法的接口时是不允许的，因为实际上T类型的该变量并没有实现m方法</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">3.Go语言中有一条隐式的规则，可以认为:*T的方法集包含了T的所有方法,因为编译器会隐式的为*T实现所有与T同名的方法，叫做包装方法。同时要求*T和T不能定义同名方法。</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">原理:</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">有如下定义:</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">type I interface{ M() }</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">type T struct{}</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">func (t T) M(){}</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">func main(){</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">    var t *T</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">    var i I</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">    i = t //并不会报错</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">}</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">以上的i=t并不会引发错误,因为go为其定义了包装方法func (t *T)M(){},</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">为什么要定义包装方法呢? 这是为了接口设计的，因为在接口中无法通过 t.M()这样的语法糖形式来调用M方法(常规调用的时候,t可以直接调用M方法的原理其实是因为Go可以解引用，相当于直接在t前加上了*进行调用，是一种语法糖)，所以在编译阶段就直接为其定义了一个包装方法，这样子*T就相当于也实现了T.M()方法了</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">4.表达式求值器:</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">第八章gorouting和通道:</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">1.如何重复在同一个位置打印字符?</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">比较有意思的一个日志打印功能，打印的时候使用\r配合fmt.Printf可以在打印的时候输出个回车，在标准输出中的表示形式就是回到刚才光标的地方再次打印</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">2.回声服务器和客户端中，用到几个往网络连接写入、读取、从标准输入中读取、往标准输出输出的方式:</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">2.1. io.WriteString(conn, string),固定往连接中写入一个字符串</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">2.2 io.Copy(os,Stdout, conn)将连接中的内容复制到标准输出</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">2.3 bufio.NewScanner(conn).Scan(),bufio.NewScanner(conn).Text()从网络连接中扫描字符内容，一旦有内容就通过Text()读取</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">2.4 io.Copy(conn, os.Stdin)将标准输入内容直接写入连接</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">3.如何输出EOF给ioutil.Reader?使用ReadAll能够顺利返回?</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">ReadAll是读取所有输入的，当我们通过Stdin或者ioutil.Reader实例是一个远程连接的时候，该怎么输入才算输入完成?</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><div>str, _ := ioutil.ReadAll(os.Stdin)</div><div><br/></div></div><div>fmt.Println("读取完了?", str)</div></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">我测试了下对于标准输入,按下Ctrl-D时会结束输入</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">4.通道的零值为nil</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">5.通道的使用只涉及到3个基础方法发送ch &lt;- v,接收 &lt;- ch,关闭 Close(ch)</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">6.有缓冲通道和无缓冲通道的区别</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14px;">无缓冲通道上的发送操作会阻塞,有缓冲通道则可以设定通道长度，将输入存储进通道，之后按需取出,</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14px;">无缓冲可以实现多个goroutine之间的同步</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">7.用户如何关闭标准输入流: 8.4的例子中使用到了io.Copy(conn, os.Stdin)，在用户端输入的时候会无限读取输入，在MacOS上测试了,通过Ctrl-D可以结束输入</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">8.make方法会初始化类型变量，var则不会，var声明之后，变量为类型的零值</span></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><img src="Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20%E7%96%91%E9%9A%BE%E7%82%B9%E8%AE%B0%E5%BD%95.resources/E3007076-5A4B-49DE-854B-8707483D4190.png" height="770" width="1892"/><br/></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><font style="font-size: 18px;">9.通道的零值是nil</font></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><font style="font-size: 18px;">10.多路复用使用select实现，可以做到同时监听多个通道，但是只会处理最先发生通信的那个通道的case:</font></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">ch1 := make(chan int)</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">ch2 := make(chan int)</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">ch3 := make(chan int)</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">var ch4 chan int //未初始化的通道，其值是零值 nil</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">select {</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">case &lt;-ch1:</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">fmt.Println("ch1来消息了")</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">case &lt;-ch2:</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">fmt.Println("ch2来消息了")</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">case ch3&lt;-1: //可以认为是一直触发的，只要ch1 ch2没消息的话,就肯定会触发ch3</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">fmt.Println("ch3发送消息了")</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">case &lt;-ch4:</span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">fmt.Println("永远都不会执行了") </span></div><div><span style="font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;">}</span></div></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">如果select中的case那里 往通道发送消息的话，可以认为一直有发生通信的</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">如果select中多个通道同时有发生通信的话，那么select会随机选择一个case执行</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">零值的通道有它特殊的用法，往nil通道中不论是发送还是接收都会阻塞，当用在select中的时候，就意味着永远不会触发它这个case</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;">从一个关闭了的通道接收值的话会立刻返回该通道的值类型的零值，如果将其用在select的case中的话也是可以认为该通道是有发生通信的</div><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"/><div style="box-sizing: border-box; margin-top: 1em; margin-bottom: 1em;"/></body></html>